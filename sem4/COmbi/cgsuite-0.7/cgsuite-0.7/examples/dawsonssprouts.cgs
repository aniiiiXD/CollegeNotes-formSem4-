/**
 * Functions for Dawsons Sprouts positions.  These are Sprouts
 * positions that include Dawson's Kayles and allow some combinations
 * of Dawson's Kayles positions to form significant Sprouts positions.
 *
 * The original reason for this code was to settle an outstanding
 * problem of finding a position in which the chirality of one
 * boundary affects the nim-value.
 * 
 * Dan Hoey, 24 October 2006
 */

/**
 * Print an error and backtrace.  Is there a better way?
 */
Error:= proc(s) s>>out;eRor(); end;

/**
 * Calculate the value of a Dawson's Kayles position with n pins.
 */
Dawson := proc(n) local i,j,opts; option remember;
    i=0;
    j=n-2;
    opts=[];
    while j >= i do
        Add(opts,Dawson(i)+Dawson(j));
        i := i + 1;
        j := j - 1;
    od;
    return C({opts|opts});
end;

////////////////////////////////////////////////////////////////
// General utilities

/**
 * Return a rotation of lis beginning with lis[rot].
 */
Rotate := proc(lis,rot) local i;
    return seq(lis[1+Mod(i+rot,Length(lis))] for i from 0 to Length(lis)-1);
end;

/**
 * Return the reverse of lis
 */
Reverse := proc(lis) local i;
    return seq(lis[Length(lis)-j] for j from 0 to Length(lis)-1);
end;

/** 
 * Return lis with incr added to each element.
 */
Translate := proc(lis,incr) local elt;
    return seq(elt+incr for elt in lis);
end;

/**
 * Return the concatenation of two lists
 */
Cat := proc(lis1,lis2) local ans;
    ans:=Clone(lis1);
    Append(ans,lis2);
    return ans;
end;

/**
 * Return lis with lis[i[1]] replaced by i[2] for i in lis.
 */
Modify := proc(lis,mods) local ans,i;
    ans:=Clone(lis);
    for i in mods do ans[i[1]]:=i[2]; od;
    return ans;
end;

/**
 * Return lis without its duplicate elements.
 */
RemoveDuplicates := proc(lis) local i,ans;
    ans:=[];
    for i in lis do
        if not Contains(ans,i) then
            Add(ans,i);
        fi;
    od;
    return ans;
end;

/**
 * Return the sum of all the elements of lis
 */
Sum := proc(lis) local i,ans;
    ans := 0;
    for i in lis do
        ans := ans + i;
    od;
    return ans;
end;

////////////////////////////////////////////////////////////////
// Group theory
// Permutations are represented as lists without repeated elements.
// Groups are represented as lists of permutations.
// We could probably make some headway from actually multiplying and
// stuff, but I don't.

/**
 * Return a list of integers from 1 to n
 */
Identity := proc(n) local i;
    return seq(i for i from 1 to n);
end;

/**
 * Cyclic group of order n
 */
CGroup := proc(n) local i,ans; option remember;
    if n==0 then return [[]]; fi;
    return seq(Rotate(Identity(n),i) for i from 0 to n-1);
end;

/**
 * Dihedral group of order 2n (for n>2).
 * Smaller n returns cyclic groups.
 */
DGroup := proc(n) local i,ans; option remember;
    if n==0 then return [[]]; fi;
    ans := Clone(CGroup(n));
    if n > 2 then
      for i from 1 to n do
        Add(ans,Reverse(ans[i]))
      od;
    fi;
    return ans;
end;

/**
 * Group of symmetries of an n-cycle and an m-cycle in the same
 * region, n<=m.
 */
CCGroupNM := proc(n,m) local i,j,ans,a2; option remember;
    ans:=[];
    for i in CGroup(n) do
      for j in CGroup(m) do
        Add(ans,Cat(i,Translate(j,n)));
      od;
    od;
    a2:=[];
    for i in ans do
        Add(a2,Cat(Reverse(seq(i[j] for j from 1 to n)),
                   Reverse(seq(i[n+j] for j from 1 to m))));
    od;
    Append(ans,a2);
    if n==m then
        a2:=[];
        for i in ans do
           Add(a2,Cat(seq(i[n+j] for j from 1 to m),
                      seq(i[j] for j from 1 to n)));
        od;
        Append(ans,a2);
    fi;
    return RemoveDuplicates(ans);
end;

/**
 * Group of symmetries of an n,m barbell, n<=m.
 *
 * Here the cycles cannot be rotated, just reversed in tandem, or
 * exchanged when they are the same size.
 */
BBGroupNM := proc(n,m) local ans, a2, i; option remember;
    ans := [Identity(n+m)];
    Add(ans, Cat(Reverse(seq(ans[1][i] for i from 1 to n)),
                 Reverse(seq(ans[1][i+n] for i from 1 to m))));
    if n==m then
        a2 := seq(Cat(seq(le[i+n] for i from 1 to m),
                      seq(le[i] for i from 1 to n))
                  for le in ans);
        Append(ans,a2);
    fi;
    return RemoveDuplicates(ans);
end;

/**
 * The result of permutation perm acting on lis.
 */
PermAction := proc (lis,perm) local i;
    return seq(lis[perm[i]] for i from 1 to Length(lis))
end;

/**
 * Compare two lists, returning the lexically least.
 */
LexMin := proc(lis1,lis2) local i;
    for i from 1 to Length(lis1) do
       if lis1[i] != lis2[i] then
           if lis1[i] < lis2[i] then
               return lis1;
           else
               return lis2;
           fi;
       fi;
    od;
    return lis1;
end;

/**
 * The only thing we use these groups for is to find a canonical
 * representative up to symmetry.  There are faster ways.
 */
Representative:= proc(lis,grp) local ans,i;
    ans:= PermAction(lis,grp[1]);
    for i from 2 to Length(grp) do
       ans := LexMin(ans, PermAction(lis,grp[i]));
    od;
    return ans;
end;

////////////////////////////////////////////////////////////////
// Utilities for Sprout expansion.
//
// Sprout position types are indices into the following lists:
// 
SproutNames := []; // Name of sprout position type
SproutNDaws := []; // Number of Dawson sites for the type
SproutGrps  := []; // Symmetry groups acting on a list of length NDaws
SproutProcs := []; // Procedures for calculating options, of the form
                   //     proc(daws,opts)
                   //     daws is a list of Dawson sites
                   //     opts is a list preloaded with the internal
                   //          Dawson moves. 
                   // proc calls
                   //     AddOption(opts,
                   //               usedDaws,
                   //               [[pt_i, daws_i],...]);
                   // to add a new option consisting of a sum of
                   //     position types.
                   //     opts is the arg to proc
                   //     usedDaws is a list of Dawsons connected to;
                   //     If they conatiain zero the option is not
                   //     added; otherwise Dawson(i-1) is added to the
                   //     option.
SproutNtns  := []; // Procedures for calculating notation;
                   // Called with ntn having created Dawson sites.
                   //     returns finished ntn.

AddPositionType := proc (name,ndaws,grp,sproc,ntnproc)
    Add(SproutNames,name);
    Add(SproutNDaws,ndaws);
    Add(SproutGrps, grp);
    Add(SproutProcs,sproc);
    Add(SproutNtns,ntnproc);
    // name +"="+Length(SproutNames)>>out;
    return Length(SproutNames);
end;

// DawsonSite is a special case, because we usually evaluate it with
// "Dawson".

DawsonSite := AddPositionType("DawsonSite",1,CGroup(1),
                              proc(daws,opts) return opts; end,
                              false);

// PosType("Sproutname") returns index into position type vectors.
SproutIx:= proc (str) local s; option remember;
    for s from 1 to Length(SproutNames) do
        if SproutNames[s]==str then return s; fi;
    od;
    Error("No Sprout method named "+str);
end;

// SproutVal(pt, daws) returns a nim value.  This canonizes but
// doesn't remember so we remember fewer values.
SproutVal := proc(pt,daws)
    return SproutValCan(pt, Representative(daws,SproutGrps[pt]));
end;

// SproutValCan(pt, cdaws) returns a nim value given a canonical list
// dawson sites.
SproutValCan := proc(pt,cdaws) local opts,opt; option remember;
    opts := seq(OptEval(opt)
                for opt in SproutProcs[pt](cdaws,
                                           PreOptions(pt,cdaws)));
    opts := C({opts|opts});
    // "" + opts + "     " + SproutNtn(pt,cdaws) + "     " +
    //      SproutNames[pt] + cdaws >>out;
    return opts;
end;

// Evaluate an option that is a sum of [pt, daws]
OptEval := proc(opt) local o,sum;
    sum:=0;
    for o in opt do
        if o[1]==DawsonSite then
            sum := sum + Dawson(o[2][1]);
        else
            sum := sum + SproutVal(o[1],o[2]);
        fi;
    od;
    return sum;
end;

// Get notation for of Sprout position
// DawsonSite is a special case because the site
SproutNtn := proc(pt,daws) local ntn,i;
    ntn:=NewNtn();
    if pt==1 then
        ntn:=MakeDawsonNtn(ntn,daws[1]-1,false);
        return AddNtn(UseD2p(UseD2p(PushD2p(ntn,"2"))),",;")[3];
    fi;
    for i from 1 to Length(daws) do
        ntn:=MakeDawsonNtn(ntn,daws[Length(daws)+1-i],true);
    od;
    return SproutNtns[pt](ntn)[3];
end;

// Describe Sprout position and options
SproutDescribe := proc(pt,daws) local cdaws,o,oi,oe,op,xo,line1;
    cdaws := Representative(daws,SproutGrps[pt]);
    SproutNames[pt]+"("+daws+")"+" = "+SproutNtn(pt,daws) >>out;
    "canonically "+SproutNames[pt]+"("+cdaws+")="+SproutValCan(pt,cdaws) >>out;
    oi:=0;
    for o in SproutProcs[pt](cdaws,PreOptions(pt,cdaws)) do
        oi := oi + 1;
        oe:= seq([SproutVal(op[1],op[2]),
                  SproutNames[op[1]] + op[2],
                  SproutNtn(op[1],op[2])]
                 for op in o
                 where op[1] != DawsonSite or op[2][1] != 0 );
        xo:=""+oi+".  Val "+OptEval(o);
        line1 := true;
        for op in oe do
            if line1 then
                xo := xo + " = ";
                line1 := false;
            else
                xo := "            + ";
            fi;
            xo + "("  + op[1] + " = " + op[2] + " = " + op[3] + ")"  >> out;
        od;
        if line1 then xo>>out; fi;
    od;
end;

PreOptions := proc(pt,cdaws) local c,i,j,opts;
    opts:=[];
    for i from 1 to Length(cdaws) do
        for j from 2 to cdaws[i] do
            Add(opts,[[pt,Modify(cdaws,[[i,j-2]])],
                      [DawsonSite,[cdaws[i]-j]]]);
        od;
    od;
    return opts;
end;

AddOption := proc(opts,usedDaws,opt) local u;
    for u in usedDaws do
        if u==0 then return; fi;
        Add(opt,[DawsonSite,[u-1]]);
    od;
    Add(opts,opt);
end;

////////////////////////////////////////////////////////////////
// Sprouts notation
//
// A notation object has
// 1. Number of z,y,x... used
// 2. Number of a,b,c... used
// 3. String of notation created so far
// 4. List of open connectors requested.
//
/*
 * Create a blank notation
 */
NewNtn := proc() return [0,0,"",[]]; end;
/*
 * Add a string to the notation
 * Str is "," for next boundary,
 * ",;" for next region,
 * "2" for an anonymous degree 2 point
 */
AddNtn := proc(ntn,str) return Modify(ntn,[[3,ntn[3]+str]]); end;

/*
 * Add a new degree-2 point.
 * if isInternal is true, allocate from z,y,x,...
 * otherwise allocate from x,y,z,...
 */
AddD2p := proc(ntn,isInternal) local let;
    if isInternal then
        let := ["z","y","x","w","v","u","t","s","r",
                "q","p","o","n","m","l","k","j","i",
                "h","g","f","e","d","c","b","a"][ntn[1]+1];
        ntn := Modify(ntn,[[1,ntn[1]+1]]);
    else
        let := ["a","b","c","d","e","f","g","h","i",
                "j","k","l","m","n","o","p","q","r",
                "s","t","u","v","w","x","y","z"][ntn[2]+1];
        ntn := Modify(ntn,[[2,ntn[2]+1]]);
    fi;
   return PushD2p(PushD2p(ntn,let),let);
end;

UseD2p := proc(ntn)
    return PopD2p(Modify(ntn,[[3,ntn[3]+TopD2p(ntn)]]));
end;

PushD2p := proc(ntn,let)
    return Modify(ntn,[[4,Cat([let],ntn[4])]]);
end;

TopD2p := proc(ntn) return ntn[4][1]; end;

PopD2p := proc(ntn)
    return Modify(ntn,[[4,seq(ntn[4][i]
                              for i from 2 to Length(ntn[4]))]]);
end;

MakeDawsonNtn := proc(ntn,n,exposeTop) local i;
    if n == 0 then
        return PushD2p(ntn,"");
    fi;
    ntn:=PushD2p(ntn,"2");
    for i from 2 to n do
        ntn:=AddNtn(UseD2p(AddD2p(UseD2p(ntn),
                                  i<n and exposeTop)),
                    ",;");
    od;
    return ntn; 
end;
////////////////////////////////////////////////////////////////
// Sprouts positions.

/*
 * A cycle of four Dawson sites.  Represent fewer sites by adding
 * zeroes.
 */
DawsonC4 := AddPositionType("DawsonC4",4,DGroup(4),
               proc(daws,opts) local i,c;
                   for c in CGroup(4) do
                       AddOption(opts, [daws[c[1]],daws[c[2]]],
                                 [[DawsonC4,
                                   Modify(daws,[[c[1],0],
                                                [c[2],1]])]]);
                   od;
                   for i from 1 to 2 do
                       AddOption(opts, [daws[i],daws[i+2]],
                                 [[DawsonSite,
                                   [daws[3-i]+daws[5-i]+1]]]);
                   od;
                   return opts;
               end,
               proc(ntn) local i;
                   for i from 1 to 4 do
                       ntn:=UseD2p(ntn);
                   od;
                   return AddNtn(ntn,",;");
               end);
/**
 * Two Dawsons separated by a two-portal boundary.
 */
TwoSplitDawson := AddPositionType("TwoSplitDawson",2,CGroup(2),
                     proc(daws,opts) local i;
                         for i from 1 to 2 do
                             // Connect Dawson i to a portal
                             AddOption(opts, [daws[i]],
                                       [[DawsonSite, [daws[3-i]+2]]]);
                             // Connect portals in Dawson i's region
                             AddOption(opts, [],
                                       [[DawsonSite, [daws[i]+1]],
                                        [DawsonSite, [daws[3-i]]]]);
                             
                         od;
                         return opts;
                     end,
                     proc(ntn) local i;
                         ntn:=UseD2p(ntn);
                         for i from 1 to 2 do
                             ntn:=UseD2p(AddD2p(ntn,true));
                         od;
                         ntn:=AddNtn(ntn,",;");
                         for i from 1 to 3 do
                             ntn:=UseD2p(ntn);
                         od;
                         return AddNtn(ntn,",;");
                     end);
/**
 * Two nonadjacent Dawsons on a four-portal boundary, where the other
 * two portals connect to a common region.
 */
TwoPlus2Dawsons := AddPositionType("TwoPlus2Dawsons",2,CGroup(2),
                   proc(daws,opts) local i;
                       // Connect two-port between Dawsons
                       AddOption(opts,[],
                                 [[DawsonSite,[Sum(daws)+1]]]);
                       // Connect two-port away from Dawsons
                       AddOption(opts,[],
                                 [[DawsonC4,Cat(daws,[0,0])]]);
                       // Connect the Dawsons to each other.
                       // The result is not exactly a 3-dawson,
                       // but has the same effect
                       AddOption(opts,daws,
                                 [[DawsonSite,[3]]]);
                       // Connect each Dawson to a portal
                       for i from 1 to 2 do
                           AddOption(opts, [daws[i]],
                                     [[DawsonC4,
                                      [0,1,1,daws[3-i]]]]);
                       od;
                       return opts;
                   end,
                   proc(ntn) local i,portal;
                       for i from 1 to 2 do
                           ntn:=UseD2p(AddD2p(ntn,true));
                       od;
                       portal:=TopD2p(ntn);
                       ntn:=AddNtn(PopD2p(ntn),",;");
                       for i from 1 to 4 do
                           ntn:=UseD2p(ntn);
                           if i==2 then ntn:=PushD2p(ntn,portal); fi;
                       od;
                       return AddNtn(ntn,",;");
                   end);
/**
 * Two three-cycles of Dawson sites.
 */
Dawson33 := AddPositionType("Dawson33",6,CCGroupNM(3,3),
                proc(daws,opts) local s,c,c2,i,j,k;
                    for s in [0,3] do
                        for c in CGroup(3) do
                            // connect two adjacent Dawsons.
                            AddOption(opts,
                                      [daws[s+c[1]],daws[s+c[2]]],
                                      [[Dawson33,
                                        Modify(daws,[[s+c[1],0],
                                                     [s+c[2],1]])]]);
                            // connect two Dawsons over a third.
                            AddOption(opts,
                                      [daws[s+c[1]],daws[s+c[2]]],
                                      [[Dawson33,
                                       Modify(daws,
                                              [[s+c[1],0],
                                               [s+c[2],0],
                                               [s+c[3],
                                                daws[s+c[3]]+1]])]]);
                        od;
                    od;
                    for c in CGroup(3) do
                       for c2 in CGroup(3) do
                           AddOption(opts,[daws[c[1]],daws[c2[1]+3]],
                                     [[DawsonBarbell,
                                       [daws[c[2]],daws[c[3]],
                                        daws[c2[2]+3],daws[c2[3]+3]]]]);
                       od;
                   od;                                                   
                   return opts;
               end,
               proc(ntn) local i;
                   for i from 1 to 6 do
                       ntn:=UseD2p(ntn);
                       if i==3 then ntn:=AddNtn(ntn,","); fi;
                   od;
                   return AddNtn(ntn,",;");
               end);

/**
 * Calculate value of two pairs of Dawsons sites connected
 * by a pier point.
 */
DawsonBarbell := AddPositionType("DawsonBarbell",4,BBGroupNM(2,2),
                proc(daws,opts) local c,i;
                    for c in BBGroupNM(2,2) do
                       // connect Dawson to near pier
                       AddOption(opts,[daws[c[1]]],
                                 [[DawsonC4,
                                   [1,daws[c[2]],
                                    daws[c[3]],daws[c[4]]]]]);
                       // connect Dawson to far pier;
                       AddOption(opts,[daws[c[1]]],
                                 [[DawsonC4,
                                   [0,1+daws[c[2]],
                                    daws[c[3]],daws[c[4]]]]]);
                    od;
                    for i from 1 to 2 do
                        // connect Dawsons on one end
                        AddOption(opts,[daws[2.i-1],daws[2.i]],
                                     [[DawsonBarbell,
                                       Modify(daws,
                                              [[2.i-1,0],[2.i,1]])]]);
                        // Connect Dawson to near other end
                        AddOption(opts,[daws[i],daws[5-i]],
                                  [[TwoPlus2Dawsons,
                                    [daws[3-i],daws[2+i]]]]);
                        // Connect Dawson to far other end
                        AddOption(opts,[daws[i],daws[i+2]],
                                  [[TwoSplitDawson,
                                    [daws[3-i],daws[5-i]]]]);
                    od;
                return opts;
                end,
                proc(ntn) local i,pier;
                    for i from 1 to 4 do
                        ntn:=UseD2p(ntn);
                        if i==2 then
                           ntn := UseD2p(AddD2p(ntn,false));
                           pier := TopD2p(ntn);
                           ntn := PopD2p(ntn);
                        fi;
                    od;
                    return AddNtn(ntn,pier+",;");
               end);

////////////////////////////////////////////////////////////////
// Testing and reporting routines

/**
 * Tests whether the DawsonBarbell lis would be different if its
 * second cycle were switched.  This must be true of some barbell
 * if two-cycle chirality is significant.
 */
HasBarbellDiff := proc(lis) local o1,o2; option remember;
    o1:=SproutVal(DawsonBarbell,lis);
    o2:=SproutVal(DawsonBarbell,PermAction(lis,[1,2,4,3]));
    return o1 != o2;
end;

BarbellDiffs := proc(st,nd) local i,o1,o2,excl,lis;
    for i from st to nd do
        lis := NCycle(i,4);
        if HasBarbellDiff(lis) then
          excl:="!!";
        else
          excl:="";
        fi;
        o1:=SproutVal(DawsonBarbell,lis);
        o2:=SproutVal(DawsonBarbell,PermAction(lis,[1,2,4,3]));
        ""+i+". Barbells "+lis+" = "+o1+":"+o2+excl >>out;
    od;
end;

/**
 * Tests cycle diff i
 */
CycleDiff := proc(st,nd) local i,o1,o2,excl,l2,lis;
    for i from st to nd do
        l2:=NCycle(i,2);
        lis:=Cat(NCycle(l2[1],3),NCycle(l2[2]-1,3));
        o1 := SproutVal(Dawson33,lis);
        o2 := SproutVal(Dawson33,PermAction(lis,[1,2,3,4,6,5]));
        if o1 != o2 then excl:="!!"; else excl:=""; fi;
        ""+i+". Cycles "+lis+" = "+o1+":"+o2+excl >>out;
    od;
end;

/**
 * Produce the "ind"th increasing sequence of n postive integers in a
 * (perhaps arbitrary) enumeration of them.
 */
NCycle := proc(ind,n) local ans,i,otc; option remember;
    if ind==1 then return Identity(n); fi;
    otc:=NCycle(ind-1,n);
    for i from 1 to n-1 do
        if otc[i] < otc[i+1]-1 then
            return Modify(otc,[[i,otc[i]+1]]);
        fi;
    od;
    return Cat(Identity(n-1),[otc[n]+1]);
end;

////////////////////////////////////////////////////////////////
// Find chiral barbells
// BarbellDiffs(1,50);

// Tabulate Dawson values
// tabulate(seq(Dawson(17.i+j) for j from 0 to 16) for i from 0 to 16) >>out;

// Uncomment this line to find the counterexamples
// CycleDiff(1,100);

// Describe the first counterexamples
// SproutDescribe(Dawson33,[2,3,4,1,3,5]);
// SproutDescribe(Dawson33,[2,3,4,1,5,3]);
